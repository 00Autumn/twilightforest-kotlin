package autumn.twilightforest.util

import autumn.twilightforest.init.block.TFBlocks
import net.minecraft.block.Block
import net.minecraft.data.family.BlockFamily
import net.minecraft.registry.Registries

object TFBlockFamilies {
    private val BASE_BLOCKS_TO_FAMILIES: MutableMap<Block, BlockFamily> = mutableMapOf()

    fun registerBlockFamily(baseBlock: Block): BlockFamily.Builder {
        val builder = BlockFamily.Builder(baseBlock)
        val blockFamily = BASE_BLOCKS_TO_FAMILIES.put(baseBlock, builder.build())
        if (blockFamily != null) {
            throw IllegalStateException("Duplicate family definition for ${Registries.BLOCK.getId(baseBlock)}")
        } else {
            return builder
        }
    }

    fun get(baseBlock: Block): BlockFamily? {
        return BASE_BLOCKS_TO_FAMILIES[baseBlock]
    }

    fun registerBlockFamilies() {
        val TWILIGHT_OAK: BlockFamily = registerBlockFamily(TFBlocks.TWILIGHT_OAK_PLANKS)
            .button(TFBlocks.TWILIGHT_OAK_BUTTON)
            .pressurePlate(TFBlocks.TWILIGHT_OAK_PRESSURE_PLATE)
            .sign(TFBlocks.TWILIGHT_OAK_SIGN, TFBlocks.TWILIGHT_OAK_WALL_SIGN)
            .fence(TFBlocks.TWILIGHT_OAK_FENCE)
            .fenceGate(TFBlocks.TWILIGHT_OAK_FENCE_GATE)
            .stairs(TFBlocks.TWILIGHT_OAK_STAIRS)
            .slab(TFBlocks.TWILIGHT_OAK_SLAB)
            .door(TFBlocks.TWILIGHT_OAK_DOOR)
            .trapdoor(TFBlocks.TWILIGHT_OAK_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
        val CANOPY: BlockFamily = registerBlockFamily(TFBlocks.CANOPY_PLANKS)
            .button(TFBlocks.CANOPY_BUTTON)
            .pressurePlate(TFBlocks.CANOPY_PRESSURE_PLATE)
            .sign(TFBlocks.CANOPY_SIGN, TFBlocks.CANOPY_WALL_SIGN)
            .fence(TFBlocks.CANOPY_FENCE)
            .fenceGate(TFBlocks.CANOPY_FENCE_GATE)
            .stairs(TFBlocks.CANOPY_STAIRS)
            .slab(TFBlocks.CANOPY_SLAB)
            .door(TFBlocks.CANOPY_DOOR)
            .trapdoor(TFBlocks.CANOPY_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
        val TWILIGHT_MANGROVE: BlockFamily = registerBlockFamily(TFBlocks.TWILIGHT_MANGROVE_PLANKS)
            .button(TFBlocks.TWILIGHT_MANGROVE_BUTTON)
            .pressurePlate(TFBlocks.TWILIGHT_MANGROVE_PRESSURE_PLATE)
            .sign(TFBlocks.TWILIGHT_MANGROVE_SIGN, TFBlocks.TWILIGHT_MANGROVE_WALL_SIGN)
            .fence(TFBlocks.TWILIGHT_MANGROVE_FENCE)
            .fenceGate(TFBlocks.TWILIGHT_MANGROVE_FENCE_GATE)
            .stairs(TFBlocks.TWILIGHT_MANGROVE_STAIRS)
            .slab(TFBlocks.TWILIGHT_MANGROVE_SLAB)
            .door(TFBlocks.TWILIGHT_MANGROVE_DOOR)
            .trapdoor(TFBlocks.TWILIGHT_MANGROVE_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
        val DARK: BlockFamily = registerBlockFamily(TFBlocks.DARK_PLANKS)
            .button(TFBlocks.DARK_BUTTON)
            .pressurePlate(TFBlocks.DARK_PRESSURE_PLATE)
            .sign(TFBlocks.DARK_SIGN, TFBlocks.DARK_WALL_SIGN)
            .fence(TFBlocks.DARK_FENCE)
            .fenceGate(TFBlocks.DARK_FENCE_GATE)
            .stairs(TFBlocks.DARK_STAIRS)
            .slab(TFBlocks.DARK_SLAB)
            .door(TFBlocks.DARK_DOOR)
            .trapdoor(TFBlocks.DARK_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
        val TIME: BlockFamily = registerBlockFamily(TFBlocks.TIME_PLANKS)
            .button(TFBlocks.TIME_BUTTON)
            .pressurePlate(TFBlocks.TIME_PRESSURE_PLATE)
            .sign(TFBlocks.TIME_SIGN, TFBlocks.TIME_WALL_SIGN)
            .fence(TFBlocks.TIME_FENCE)
            .fenceGate(TFBlocks.TIME_FENCE_GATE)
            .stairs(TFBlocks.TIME_STAIRS)
            .slab(TFBlocks.TIME_SLAB)
            .door(TFBlocks.TIME_DOOR)
            .trapdoor(TFBlocks.TIME_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
        val TRANSFORMATION: BlockFamily = registerBlockFamily(TFBlocks.TRANSFORMATION_PLANKS)
            .button(TFBlocks.TRANSFORMATION_BUTTON)
            .pressurePlate(TFBlocks.TRANSFORMATION_PRESSURE_PLATE)
            .sign(TFBlocks.TRANSFORMATION_SIGN, TFBlocks.TRANSFORMATION_WALL_SIGN)
            .fence(TFBlocks.TRANSFORMATION_FENCE)
            .fenceGate(TFBlocks.TRANSFORMATION_FENCE_GATE)
            .stairs(TFBlocks.TRANSFORMATION_STAIRS)
            .slab(TFBlocks.TRANSFORMATION_SLAB)
            .door(TFBlocks.TRANSFORMATION_DOOR)
            .trapdoor(TFBlocks.TRANSFORMATION_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
        val MINING: BlockFamily = registerBlockFamily(TFBlocks.MINING_PLANKS)
            .button(TFBlocks.MINING_BUTTON)
            .pressurePlate(TFBlocks.MINING_PRESSURE_PLATE)
            .sign(TFBlocks.MINING_SIGN, TFBlocks.MINING_WALL_SIGN)
            .fence(TFBlocks.MINING_FENCE)
            .fenceGate(TFBlocks.MINING_FENCE_GATE)
            .stairs(TFBlocks.MINING_STAIRS)
            .slab(TFBlocks.MINING_SLAB)
            .door(TFBlocks.MINING_DOOR)
            .trapdoor(TFBlocks.MINING_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
        val SORTING: BlockFamily = registerBlockFamily(TFBlocks.SORTING_PLANKS)
            .button(TFBlocks.SORTING_BUTTON)
            .pressurePlate(TFBlocks.SORTING_PRESSURE_PLATE)
            .sign(TFBlocks.SORTING_SIGN, TFBlocks.SORTING_WALL_SIGN)
            .fence(TFBlocks.SORTING_FENCE)
            .fenceGate(TFBlocks.SORTING_FENCE_GATE)
            .stairs(TFBlocks.SORTING_STAIRS)
            .slab(TFBlocks.SORTING_SLAB)
            .door(TFBlocks.SORTING_DOOR)
            .trapdoor(TFBlocks.SORTING_TRAPDOOR)
            .group("wooden")
            .unlockCriterionName("has_planks")
            .build()
    }
}